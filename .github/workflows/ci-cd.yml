name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: mikaelschulz70/dtime/backend
  IMAGE_NAME_FRONTEND: mikaelschulz70/dtime/frontend

jobs:
  # Frontend Build and Test
  frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Setup Node.js
      uses: actions/setup-node@v6
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: npm ci

    - name: Run frontend linting
      run: |
        if [ -f package.json ] && grep -q '"lint"' package.json; then
          npm run lint
        else
          echo "No lint script found, skipping..."
        fi

    - name: Run frontend tests
      run: |
        if [ -f package.json ] && grep -q '"test"' package.json; then
          npm run test -- --coverage --watchAll=false
        else
          echo "No test script found, skipping..."
        fi

    - name: Build frontend
      run: npm run build
      env:
        CI: false  # Treat warnings as warnings, not errors

    - name: Upload frontend build artifacts
      uses: actions/upload-artifact@v6
      with:
        name: frontend-build
        path: frontend/dist/
        retention-days: 1

  # Backend Build and Test
  backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_DB: dtime_test
          POSTGRES_USER: dtime_test
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Setup Java
      uses: actions/setup-java@v5
      with:
        java-version: '25'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run backend tests
      run: mvn test
      env:
        SPRING_PROFILES_ACTIVE: test
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/dtime_test
        SPRING_DATASOURCE_USERNAME: dtime_test
        SPRING_DATASOURCE_PASSWORD: test_password
        SPRING_JPA_HIBERNATE_DDL_AUTO: create-drop

    - name: Build backend
      run: mvn clean package -DskipTests
      env:
        SPRING_PROFILES_ACTIVE: prod

    - name: Upload backend build artifacts
      uses: actions/upload-artifact@v6
      with:
        name: backend-build
        path: backend/target/*.jar
        retention-days: 1

  # Docker Build
  docker-build:
    needs: [frontend, backend]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Download frontend build
      uses: actions/download-artifact@v7
      with:
        name: frontend-build
        path: frontend/dist/

    - name: Download backend build
      uses: actions/download-artifact@v7
      with:
        name: backend-build
        path: backend/target/

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=sha-
          type=sha
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=sha-
          type=sha
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Debug backend metadata
      run: |
        echo "Backend tags that will be created:"
        echo "${{ steps.meta-backend.outputs.tags }}"
        echo "Backend labels:"
        echo "${{ steps.meta-backend.outputs.labels }}"

    - name: Build and push backend Docker image
      uses: docker/build-push-action@v6
      with:
        context: ./backend
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Debug frontend metadata
      run: |
        echo "Frontend tags that will be created:"
        echo "${{ steps.meta-frontend.outputs.tags }}"
        echo "Frontend labels:"
        echo "${{ steps.meta-frontend.outputs.labels }}"

    - name: Build and push frontend Docker image
      uses: docker/build-push-action@v6
      with:
        context: ./frontend
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Integration Tests
  integration-test:
    needs: [docker-build]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Verify Docker Compose availability
      run: |
        echo "Docker version:"
        docker --version
        echo "Docker Compose version:"
        docker compose version
        echo "Available Docker commands:"
        docker --help | grep -E "compose|buildx" || true

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Check available images in registry
      run: |
        echo "Checking what images exist in the registry..."
        
        # Try to list images to see what's actually available
        echo "Attempting to pull latest backend image..."
        docker pull ghcr.io/mikaelschulz70/dtime/backend:latest || echo "No latest backend image found"
        
        echo "Attempting to pull latest frontend image..."
        docker pull ghcr.io/mikaelschulz70/dtime/frontend:latest || echo "No latest frontend image found"
        
        echo "Attempting to pull sha-tagged backend image..."
        docker pull ghcr.io/mikaelschulz70/dtime/backend:sha-${{ github.sha }} || echo "No sha-prefixed backend image found"
        
        echo "Attempting to pull sha-tagged frontend image..."
        docker pull ghcr.io/mikaelschulz70/dtime/frontend:sha-${{ github.sha }} || echo "No sha-prefixed frontend image found"
        
        echo "Now checking for the exact SHA tags we expect..."
        BACKEND_IMG="${{ env.REGISTRY }}/mikaelschulz70/dtime/backend:${{ github.sha }}"
        FRONTEND_IMG="${{ env.REGISTRY }}/mikaelschulz70/dtime/frontend:${{ github.sha }}"
        
        echo "Backend image: $BACKEND_IMG"
        echo "Frontend image: $FRONTEND_IMG"
        
        echo "Attempting to pull backend image..."
        if docker pull "$BACKEND_IMG"; then
          echo "âœ… Backend image exists and is accessible"
          BACKEND_AVAILABLE=true
        else
          echo "âŒ Backend image not found or not accessible"
          BACKEND_AVAILABLE=false
        fi
        
        echo "Attempting to pull frontend image..."
        if docker pull "$FRONTEND_IMG"; then
          echo "âœ… Frontend image exists and is accessible"
          FRONTEND_AVAILABLE=true
        else
          echo "âŒ Frontend image not found or not accessible"  
          FRONTEND_AVAILABLE=false
        fi
        
        # If SHA-tagged images aren't available, try to use latest tags as fallback
        if [[ "$BACKEND_AVAILABLE" == "false" || "$FRONTEND_AVAILABLE" == "false" ]]; then
          echo "âš ï¸ SHA-tagged images not found. Checking if we can use latest tags instead..."
          
          echo "Trying latest backend image..."
          if docker pull ghcr.io/mikaelschulz70/dtime/backend:latest >/dev/null 2>&1; then
            echo "âœ… Latest backend image available"
            BACKEND_FALLBACK="ghcr.io/mikaelschulz70/dtime/backend:latest"
          else
            echo "âŒ Latest backend image not available"
            BACKEND_FALLBACK=""
          fi
          
          echo "Trying latest frontend image..."
          if docker pull ghcr.io/mikaelschulz70/dtime/frontend:latest >/dev/null 2>&1; then
            echo "âœ… Latest frontend image available"
            FRONTEND_FALLBACK="ghcr.io/mikaelschulz70/dtime/frontend:latest"
          else
            echo "âŒ Latest frontend image not available"
            FRONTEND_FALLBACK=""
          fi
          
          if [[ -n "$BACKEND_FALLBACK" && -n "$FRONTEND_FALLBACK" ]]; then
            echo "ðŸ”„ Using latest tags as fallback for integration tests"
            echo "BACKEND_IMAGE=$BACKEND_FALLBACK" >> $GITHUB_ENV
            echo "FRONTEND_IMAGE=$FRONTEND_FALLBACK" >> $GITHUB_ENV
          else
            echo "âŒ Neither SHA-tagged nor latest images are available. Cannot proceed."
            echo ""
            echo "Possible causes:"
            echo "1. Docker build job failed to push images"
            echo "2. Images were pushed with different tags than expected"
            echo "3. GitHub Container Registry packages are private (need to be made public)"
            echo "4. Registry authentication issues"
            echo ""
            echo "To fix:"
            echo "- Check the docker-build job logs for build/push failures"
            echo "- Verify GitHub Container Registry package visibility settings"
            echo "- Check if images exist at: https://github.com/MikaelSchulz70/dtime/pkgs"
            exit 1
          fi
        fi

    - name: Create test environment file
      run: |
        cat > .env.test << EOF
        # Database Configuration
        POSTGRES_DB=dtime_test
        POSTGRES_USER=dtime_test
        POSTGRES_PASSWORD=test_password
        
        # Email Configuration (dummy for testing)
        MAIL_USERNAME=test@example.com
        MAIL_PASSWORD=dummy-password
        
        # Security
        SECURITY_CSRF_ENABLED=false
        
        # Frontend
        REACT_APP_BACKEND_URL=http://localhost:8080
        NODE_ENV=production
        EOF

    - name: Start test environment
      continue-on-error: true
      run: |
        # Use environment variables set by image verification step, or default to SHA tags
        BACKEND_IMAGE="${BACKEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}}"
        FRONTEND_IMAGE="${FRONTEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}}"
        
        # Export for use in this step
        export BACKEND_IMAGE
        export FRONTEND_IMAGE
        
        # Debug: Print environment variables
        echo "BACKEND_IMAGE: $BACKEND_IMAGE"
        echo "FRONTEND_IMAGE: $FRONTEND_IMAGE"
        
        # Create database initialization script for dtime schema
        cat > init-test-db.sql << EOF
        -- Create the dtime schema that Liquibase and Hibernate expect
        CREATE SCHEMA IF NOT EXISTS dtime;
        
        -- Grant permissions to the test user
        GRANT ALL PRIVILEGES ON SCHEMA dtime TO dtime_test;
        GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA dtime TO dtime_test;
        GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA dtime TO dtime_test;
        GRANT USAGE ON SCHEMA dtime TO dtime_test;
        GRANT CREATE ON SCHEMA dtime TO dtime_test;
        
        -- Set search path to include dtime schema
        ALTER USER dtime_test SET search_path TO dtime,public;
        EOF
        
        # Create a test docker-compose file
        cat > docker-compose.test.yml << EOF
        services:
          dtime-db:
            image: postgres:14
            environment:
              POSTGRES_DB: dtime_test
              POSTGRES_USER: dtime_test
              POSTGRES_PASSWORD: test_password
            ports:
              - "5432:5432"
            volumes:
              - ./init-test-db.sql:/docker-entrypoint-initdb.d/init-test-db.sql
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U dtime_test -d dtime_test"]
              interval: 10s
              timeout: 5s
              retries: 5

          dtime-backend:
            image: \${BACKEND_IMAGE}
            environment:
              SPRING_PROFILES_ACTIVE: docker
              DATABASE_URL: jdbc:postgresql://dtime-db:5432/dtime_test
              DATABASE_USERNAME: dtime_test
              DATABASE_PASSWORD: test_password
              MAIL_USERNAME: test@example.com
              MAIL_PASSWORD: dummy-password
              SECURITY_CSRF_ENABLED: false
              SSL_KEYSTORE_PASSWORD: dt2020
              SPRING_LIQUIBASE_DEFAULT_SCHEMA: dtime
              SPRING_JPA_PROPERTIES_HIBERNATE_DEFAULT_SCHEMA: dtime
              MANAGEMENT_HEALTH_MAIL_ENABLED: false
              MANAGEMENT_HEALTH_DISKSPACE_ENABLED: false
            ports:
              - "8080:8080"
              - "8443:8443"
            depends_on:
              dtime-db:
                condition: service_healthy
            healthcheck:
              test: ["CMD-SHELL", "curl -f -k https://localhost:8443/actuator/health || exit 1"]
              interval: 30s
              timeout: 15s
              retries: 8
              start_period: 180s

          dtime-frontend:
            image: \${FRONTEND_IMAGE}
            environment:
              REACT_APP_BACKEND_URL: https://localhost:8443
              NODE_ENV: production
            ports:
              - "3000:80"
            depends_on:
              - dtime-backend
            healthcheck:
              test: ["CMD-SHELL", "curl -f http://localhost:80/ || exit 1"]
              interval: 30s
              timeout: 10s
              retries: 3
        EOF
        
        docker compose -f docker-compose.test.yml up -d

    - name: Debug backend container startup
      continue-on-error: true
      run: |
        # Use environment variables set by image verification step, or default to SHA tags
        BACKEND_IMAGE="${BACKEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}}"
        FRONTEND_IMAGE="${FRONTEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}}"
        export BACKEND_IMAGE FRONTEND_IMAGE
        
        echo "=== IMMEDIATE DEBUGGING AFTER CONTAINER START ==="
        echo "Current service status:"
        docker compose -f docker-compose.test.yml ps
        
        echo "Initial backend status:"
        docker compose -f docker-compose.test.yml ps dtime-backend || true
        echo "Initial backend logs (FULL OUTPUT):"
        docker compose -f docker-compose.test.yml logs --no-log-prefix dtime-backend || true
        
        echo "=== CHECKING FOR STARTUP ERRORS ==="
        echo "Searching for ERROR/WARN/EXCEPTION in logs:"
        docker compose -f docker-compose.test.yml logs dtime-backend 2>&1 | grep -i "error\|exception\|warn\|fail" | tail -20 || echo "No errors found in basic search"
        
        echo "=== CHECKING LIQUIBASE SPECIFIC ISSUES ==="
        echo "Searching for Liquibase-related messages:"
        docker compose -f docker-compose.test.yml logs dtime-backend 2>&1 | grep -i "liquibase\|schema\|database\|connection\|ssl\|keystore" | tail -15 || echo "No Liquibase/database/SSL messages found"
        
        echo "=== CHECKING DATABASE CONNECTIVITY ==="
        echo "Testing database connection from backend container:"
        docker compose -f docker-compose.test.yml exec -T dtime-backend nc -zv dtime-db 5432 || echo "Database connectivity test failed"
        
        # Wait a bit for Spring Boot to potentially start
        echo "Waiting 30 seconds for Spring Boot to start..."
        sleep 30
        
        echo "Backend status after 30s:"
        docker compose -f docker-compose.test.yml ps dtime-backend || true
        echo "Backend logs after 30s:"
        docker compose -f docker-compose.test.yml logs dtime-backend || true
        
        # Check environment variables
        echo "Backend container environment variables:"
        docker compose -f docker-compose.test.yml exec -T dtime-backend env | grep -E "(DATABASE|SPRING|SSL)" || echo "No relevant env vars found"
        
        # Test if container is still running
        if docker compose -f docker-compose.test.yml ps dtime-backend | grep -q "Up"; then
          echo "Backend container is running, testing endpoints..."
          
          # Test the health check command manually
          echo "Testing actuator health endpoint manually:"
          docker compose -f docker-compose.test.yml exec -T dtime-backend curl -f -k https://localhost:8443/actuator/health || echo "Actuator health check failed"
          
          echo "Testing actuator health endpoint with verbose output:"
          docker compose -f docker-compose.test.yml exec -T dtime-backend curl -v -k https://localhost:8443/actuator/health || echo "Verbose actuator health check failed"
          
          # Check if the backend port is actually listening
          echo "Checking if backend ports are listening:"
          docker compose -f docker-compose.test.yml exec -T dtime-backend netstat -tlnp 2>/dev/null || echo "netstat not available"
          docker compose -f docker-compose.test.yml exec -T dtime-backend ss -tlnp 2>/dev/null || echo "ss not available"
          
          # Test basic connectivity
          echo "Testing basic HTTPS connectivity:"
          docker compose -f docker-compose.test.yml exec -T dtime-backend curl -k https://localhost:8443/ || echo "Basic HTTPS connection failed"
          
        else
          echo "âŒ Backend container is not running!"
          echo "Final backend logs:"
          docker compose -f docker-compose.test.yml logs dtime-backend || true
        fi

    - name: Wait for services to be ready
      run: |
        # Use environment variables set by image verification step, or default to SHA tags
        BACKEND_IMAGE="${BACKEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}}"
        FRONTEND_IMAGE="${FRONTEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}}"
        export BACKEND_IMAGE FRONTEND_IMAGE
        echo "Waiting for services to be ready..."
        
        if [ ! -f docker-compose.test.yml ]; then
          echo "âŒ docker-compose.test.yml not found! Cannot proceed with service health checks."
          exit 1
        fi
        
        echo "=== WAITING FOR HEALTH CHECKS ==="
        echo "Current service status:"
        docker compose -f docker-compose.test.yml ps
        
        timeout 600s bash -c '
          while true; do
            echo "Checking backend health status..."
            BACKEND_STATUS=$(docker compose -f docker-compose.test.yml ps dtime-backend --format "table {{.Status}}" | tail -n +2)
            echo "Backend status: $BACKEND_STATUS"
            
            if echo "$BACKEND_STATUS" | grep -q "Up.*healthy"; then
              echo "âœ… Backend is healthy!"
              break
            elif echo "$BACKEND_STATUS" | grep -q "Exited"; then
              echo "âŒ Backend container has exited. Full logs:"
              docker compose -f docker-compose.test.yml logs dtime-backend
              exit 1
            else
              echo "Backend not healthy yet, waiting..."
              echo "Current full service status:"
              docker compose -f docker-compose.test.yml ps
              echo "Backend logs (last 10 lines):"
              docker compose -f docker-compose.test.yml logs --tail=10 dtime-backend || true
            fi
            
            sleep 10
          done
        ' || {
          echo "Backend failed to become healthy. Final status:"
          docker compose -f docker-compose.test.yml ps
          echo "Complete backend logs:"
          docker compose -f docker-compose.test.yml logs dtime-backend
          echo "Backend container inspect:"
          docker inspect $(docker compose -f docker-compose.test.yml ps -q dtime-backend) || true
          exit 1
        }
        
        echo "Waiting for frontend to be healthy..."
        timeout 120s bash -c '
          while true; do
            echo "Checking frontend health status..."
            FRONTEND_STATUS=$(docker compose -f docker-compose.test.yml ps dtime-frontend --format "table {{.Status}}" | tail -n +2)
            echo "Frontend status: $FRONTEND_STATUS"
            
            if echo "$FRONTEND_STATUS" | grep -q "Up.*healthy"; then
              echo "âœ… Frontend is healthy!"
              break
            elif echo "$FRONTEND_STATUS" | grep -q "Exited"; then
              echo "âŒ Frontend container has exited."
              exit 1
            else
              echo "Frontend not healthy yet, waiting..."
              echo "Frontend logs (last 5 lines):"
              docker compose -f docker-compose.test.yml logs --tail=5 dtime-frontend || true
            fi
            
            sleep 10
          done
        ' || {
          echo "Frontend failed to become healthy. Final status:"
          docker compose -f docker-compose.test.yml ps
          docker compose -f docker-compose.test.yml logs dtime-frontend
          exit 1
        }

    - name: Pre-integration test verification
      run: |
        # Use environment variables set by image verification step, or default to SHA tags
        BACKEND_IMAGE="${BACKEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}}"
        FRONTEND_IMAGE="${FRONTEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}}"
        export BACKEND_IMAGE FRONTEND_IMAGE
        
        echo "=== PRE-INTEGRATION TEST VERIFICATION ==="
        echo "Final service status before integration tests:"
        docker compose -f docker-compose.test.yml ps
        
        echo "Testing direct container connectivity:"
        echo "Backend container IP and ports:"
        docker compose -f docker-compose.test.yml exec -T dtime-backend hostname -I || true
        docker compose -f docker-compose.test.yml exec -T dtime-backend ss -tlnp | grep ":8443" || true
        
        echo "Testing localhost port availability:"
        ss -tlnp | grep ":8443" || echo "Port 8443 not listening on host"
        ss -tlnp | grep ":3000" || echo "Port 3000 not listening on host"

    - name: Run integration tests
      run: |
        echo "=== INTEGRATION TESTS STARTING ==="
        
        echo "Testing backend health endpoint (HTTPS)..."
        if curl -f -k https://localhost:8443/actuator/health; then
          echo "âœ… Backend health check passed"
        else
          echo "âŒ Backend health check failed"
          exit 1
        fi
        
        echo "Testing backend API endpoints (HTTPS)..."
        # Test that API endpoint exists and returns expected HTTP status
        RESPONSE=$(curl -I -k -s https://localhost:8443/api/users 2>/dev/null | head -n 1)
        echo "API response: $RESPONSE"
        if echo "$RESPONSE" | grep -E "(401|403|200)"; then
          echo "âœ… Backend API endpoint responded with expected status"
        else
          echo "âŒ Backend API endpoint failed or returned unexpected status"
          echo "Full response headers:"
          curl -I -k -v https://localhost:8443/api/users || true
          exit 1
        fi
        
        echo "Testing frontend availability..."
        if curl -f http://localhost:3000/; then
          echo "âœ… Frontend is accessible"
        else
          echo "âŒ Frontend is not accessible"
          echo "Frontend logs:"
          docker compose -f docker-compose.test.yml logs dtime-frontend || true
          exit 1
        fi
        
        echo "Testing backend-frontend connectivity..."
        # Check that frontend can reach backend (should get login redirect or API response)
        FRONTEND_API_RESPONSE=$(curl -I -s http://localhost:3000/api/users 2>/dev/null | head -n 1)
        echo "Frontend-to-backend API response: $FRONTEND_API_RESPONSE"
        if echo "$FRONTEND_API_RESPONSE" | grep -E "(401|403|200|302)"; then
          echo "âœ… Frontend can communicate with backend"
        else
          echo "âš ï¸ Frontend-backend communication test inconclusive, but not failing build"
          echo "This might be due to proxy configuration differences"
        fi
        
        echo "=== ALL INTEGRATION TESTS COMPLETED SUCCESSFULLY ==="

    - name: Collect logs on failure
      if: failure()
      run: |
        # Use environment variables set by image verification step, or default to SHA tags
        BACKEND_IMAGE="${BACKEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}}"
        FRONTEND_IMAGE="${FRONTEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}}"
        export BACKEND_IMAGE FRONTEND_IMAGE
        if [ -f docker-compose.test.yml ]; then
          echo "=== Backend Logs ==="
          docker compose -f docker-compose.test.yml logs dtime-backend || echo "Could not get backend logs"
          echo "=== Frontend Logs ==="
          docker compose -f docker-compose.test.yml logs dtime-frontend || echo "Could not get frontend logs"
          echo "=== Database Logs ==="
          docker compose -f docker-compose.test.yml logs dtime-db || echo "Could not get database logs"
        else
          echo "docker-compose.test.yml not found, cannot collect service logs"
          echo "Listing all containers for debugging:"
          docker ps -a || true
        fi

    - name: Cleanup test environment
      if: always()
      run: |
        # Use environment variables set by image verification step, or default to SHA tags
        BACKEND_IMAGE="${BACKEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}}"
        FRONTEND_IMAGE="${FRONTEND_IMAGE:-${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}}"
        export BACKEND_IMAGE FRONTEND_IMAGE
        if [ -f docker-compose.test.yml ]; then
          echo "Cleaning up test environment..."
          docker compose -f docker-compose.test.yml down -v
        else
          echo "docker-compose.test.yml not found, skipping cleanup"
          echo "Checking for any running containers to clean up..."
          docker ps -a --filter "name=dtime-" --format "table {{.Names}}\t{{.Status}}" || true
          docker stop $(docker ps -q --filter "name=dtime-") 2>/dev/null || true
          docker rm $(docker ps -aq --filter "name=dtime-") 2>/dev/null || true
        fi

  # Deployment Test (Dry Run)
  deployment-test:
    needs: [integration-test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Test deployment scripts
      run: |
        echo "Testing build script..."
        chmod +x ./build-docker.sh
        # Test the build script syntax
        bash -n ./build-docker.sh
        
        echo "Testing deployment script..."
        chmod +x ./deploy.sh
        # Test the deployment script syntax  
        bash -n ./deploy.sh
        
        echo "Testing package script..."
        chmod +x ./package.sh
        # Test the package script syntax
        bash -n ./package.sh

    - name: Validate docker-compose files
      run: |
        echo "Validating docker-compose.yml..."
        docker compose -f docker-compose.yml config -q
        
        echo "Deployment validation completed successfully!"

  # Security Scanning
  security-scan:
    needs: [docker-build]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Run Trivy vulnerability scanner on backend
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-backend-results.sarif'

    - name: Run Trivy vulnerability scanner on frontend  
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-frontend-results.sarif'

    - name: List generated SARIF files
      if: always()
      run: |
        echo "Files in current directory:"
        ls -la *.sarif || echo "No SARIF files found"
        echo "All files:"
        ls -la

    - name: Upload backend SARIF results
      uses: github/codeql-action/upload-sarif@v4
      if: always() && hashFiles('trivy-backend-results.sarif') != ''
      with:
        sarif_file: trivy-backend-results.sarif
        category: 'backend-security'

    - name: Upload frontend SARIF results  
      uses: github/codeql-action/upload-sarif@v4
      if: always() && hashFiles('trivy-frontend-results.sarif') != ''
      with:
        sarif_file: trivy-frontend-results.sarif
        category: 'frontend-security'